/* Copyright (c) 2001 - 2007 TOPP - www.openplans.org. All rights reserved.
 * This code is licensed under the GPL 2.0 license, availible at the root
 * application directory.
 */
package org.geoserver.platform;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


/**
 *  Base class for exceptions generated by a service.
 *  <p>
 *  This class is based off the OGC idea of an exception, which contains
 *  a {@link #code}, and {@link #locator}. Futhermore optional fragments of
 *  {@link #exceptionText} may be associated with the exception.
 *  </p>
 *
 * @author Justin Deoliveira, The Open Planning Project, jdeolive@openplans.org
 *
 */
public class ServiceException extends RuntimeException {
    /**
     * Serial UID
     */
    private static final long serialVersionUID = 7254349181794561723L;
    
    public static final String NEW_LINE = System.getProperty("line.separator");

    /**
     * Application specfic code.
     */
    String code;

    /**
     * Application specific locator
     */
    String locator;

    /**
     * List of text recording information about the exception
     */
    List exceptionText = new ArrayList();

    /**
     * Constructs the exception from a message.
     *
     * @param message The message describing the exception.
     */
    public ServiceException(String message) {
        super(message);
    }

    /**
     * Constructs the exception from a message and causing exception.
     *
     * @param message The message describing the exception.
     * @param cause The case of the exception.
     */
    public ServiceException(String message, Throwable cause) {
        super(message, cause);
    }

    /**
     * Constructs the exception from a message, causing exception, and code.
     *
     * @param message The message describing the exception.
     * @param cause The case of the exception.
     * @param code The application specific exception code for the exception.
     */
    public ServiceException(String message, Throwable cause, String code) {
        this(message, cause);
        this.code = code;
    }

    /**
     * Constructs the exception from a message, causing exception, code, and
     * locator.
     *
     * @param message The message describing the exception.
     * @param cause The case of the exception.
     * @param code The application specific exception code for the exception.
     * @param locator The application specific locator for the exception.
     */
    public ServiceException(String message, Throwable cause, String code, String locator) {
        this(message, cause, code);
        this.locator = locator;
    }

    /**
     * Constructs the exception from a message, and code.
     *
     * @param message The message describing the exception.
     * @param code The application specific exception code for the exception.
     */
    public ServiceException(String message, String code) {
        super(message);
        this.code = code;
    }

    /**
     * Constructs the exception from a message,code, and
     * locator.
     *
     * @param message The message describing the exception.
     * @param code The application specific exception code for the exception.
     * @param locator The application specific locator for the exception.
     */
    public ServiceException(String message, String code, String locator) {
        this(message, code);
        this.locator = locator;
    }

    /**
     * Constructs the exception from a causing exception.
     *
     * @param cause The case of the exception.
     */
    public ServiceException(Throwable cause) {
        super(cause);
    }

    /**
     * Constructs the exception from causing exception, and code.
     *
     * @param cause The case of the exception.
     * @param code The application specific exception code for the exception.
     */
    public ServiceException(Throwable cause, String code) {
        this(cause);
        this.code = code;
    }

    /**
     * Constructs the exception from a causing exception, code, and locator.
     *
     * @param cause The case of the exception.
     * @param code The application specific exception code for the exception.
     * @param locator The application specific locator for the exception.
     */
    public ServiceException(Throwable cause, String code, String locator) {
        this(cause, code);
        this.locator = locator;
    }

    /**
     * @return The application specifc code of the exception.
     */
    public String getCode() {
        return code;
    }

    /**
     * Sets the code for the exception.
     *
     * @param code The application specific code.
     */
    public void setCode(String code) {
        this.code = code;
    }

    /**
     * @return The application specific locator.
     */
    public String getLocator() {
		// Thijs Brentjens: make sure that the locator is XML encoded, as defense against XSS
        return this.encodeXML(locator);
    }

    /**
     * Sets the locator for the exception.
     *
     * @return The application specific locator.
     */
    public void setLocator(String locator) {
        this.locator = locator;
    }

    /**
     * Returns the list of text fragments which provide additonal information
     * about the exception.
     * <p>
     * Text fragements may be added directly to the list with:
     * <code>
     * exception.getExceptionTest().add( "text fragment" );
     * </code>
     * </p>
     * @return A list of String recording information about the exception.
     */
    public List getExceptionText() {
        return exceptionText;
    }
    
    @Override
    public String toString() {
		// Thijs Brentjens: encode the string against XSS vulnerability       
		String msg = this.encodeXML(super.toString());
        if(exceptionText == null || exceptionText.size() == 0)
            return msg;
        
        StringBuffer sb = new StringBuffer(msg);
        for (Iterator it = exceptionText.iterator(); it.hasNext();) {
            String extraMessage = (String) it.next();
            sb.append(NEW_LINE).append(extraMessage);
        }
        return sb.toString();
    }

	// Thijs Brentjens: encoding XML in Service Exceptions should be done to avoid XSS
	// This method is already available in org.geoserver.ows.util.ResponseUtils. Requires refactoring.
	public static String encodeXML(String inData) {
        //return null, if null is passed as argument
        if (inData == null) {
            return null;
        }

        //if no special characters, just return
        //(for optimization. Though may be an overhead, but for most of the
        //strings, this will save time)
        if ((inData.indexOf('&') == -1) && (inData.indexOf('<') == -1)
                && (inData.indexOf('>') == -1) && (inData.indexOf('\'') == -1)
                && (inData.indexOf('\"') == -1)) {
            return inData;
        }

        //get the length of input String
        int length = inData.length();

        //create a StringBuffer of double the size (size is just for guidance
        //so as to reduce increase-capacity operations. The actual size of
        //the resulting string may be even greater than we specified, but is
        //extremely rare)
        StringBuffer buffer = new StringBuffer(2 * length);

        char charToCompare;

        //iterate over the input String
        for (int i = 0; i < length; i++) {
            charToCompare = inData.charAt(i);

            //if the ith character is special character, replace by code
            if (charToCompare == '&') {
                buffer.append("&amp;");
            } else if (charToCompare == '<') {
                buffer.append("&lt;");
            } else if (charToCompare == '>') {
                buffer.append("&gt;");
            } else if (charToCompare == '\"') {
                buffer.append("&quot;");
            } else if (charToCompare == '\'') {
                buffer.append("&apos;");
            } else {
                buffer.append(charToCompare);
            }
        }

        //return the encoded string
        return buffer.toString();
    }
}
